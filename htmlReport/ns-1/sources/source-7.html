


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > JavaFile</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.squareup.javapoet</a>
</div>

<h1>Coverage Summary for Class: JavaFile (com.squareup.javapoet)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JavaFile</td>
<td class="coverageStat">
  <span class="percent">
    89.5%
  </span>
  <span class="absValue">
    (17/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81%
  </span>
  <span class="absValue">
    (34/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.8%
  </span>
  <span class="absValue">
    (86/98)
  </span>
</td>
</tr>
  <tr>
    <td class="name">JavaFile$1</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaFile$2</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaFile$Builder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (6/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (23/23)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (32/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.9%
  </span>
  <span class="absValue">
    (40/52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.2%
  </span>
  <span class="absValue">
    (116/130)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright (C) 2015 Square, Inc.
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; * http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package com.squareup.javapoet;
&nbsp;
&nbsp;import java.io.ByteArrayInputStream;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.OutputStreamWriter;
&nbsp;import java.io.Writer;
&nbsp;import java.net.URI;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.Path;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.TreeSet;
&nbsp;import javax.annotation.processing.Filer;
&nbsp;import javax.lang.model.element.Element;
&nbsp;import javax.tools.JavaFileObject;
&nbsp;import javax.tools.JavaFileObject.Kind;
&nbsp;import javax.tools.SimpleJavaFileObject;
&nbsp;
&nbsp;import static com.squareup.javapoet.Util.checkArgument;
&nbsp;import static com.squareup.javapoet.Util.checkNotNull;
&nbsp;import static java.nio.charset.StandardCharsets.UTF_8;
&nbsp;
&nbsp;/** A Java file containing a single top level class. */
<b class="fc">&nbsp;public final class JavaFile {</b>
<b class="fc">&nbsp;  private static final Appendable NULL_APPENDABLE = new Appendable() {</b>
&nbsp;    @Override public Appendable append(CharSequence charSequence) {
<b class="fc">&nbsp;      return this;</b>
&nbsp;    }
&nbsp;    @Override public Appendable append(CharSequence charSequence, int start, int end) {
<b class="nc">&nbsp;      return this;</b>
&nbsp;    }
&nbsp;    @Override public Appendable append(char c) {
<b class="fc">&nbsp;      return this;</b>
&nbsp;    }
&nbsp;  };
&nbsp;
&nbsp;  public final CodeBlock fileComment;
&nbsp;  public final String packageName;
&nbsp;  public final TypeSpec typeSpec;
&nbsp;  public final boolean skipJavaLangImports;
&nbsp;  private final Set&lt;String&gt; staticImports;
&nbsp;  private final Set&lt;String&gt; alwaysQualify;
&nbsp;  private final String indent;
&nbsp;
<b class="fc">&nbsp;  private JavaFile(Builder builder) {</b>
<b class="fc">&nbsp;    this.fileComment = builder.fileComment.build();</b>
<b class="fc">&nbsp;    this.packageName = builder.packageName;</b>
<b class="fc">&nbsp;    this.typeSpec = builder.typeSpec;</b>
<b class="fc">&nbsp;    this.skipJavaLangImports = builder.skipJavaLangImports;</b>
<b class="fc">&nbsp;    this.staticImports = Util.immutableSet(builder.staticImports);</b>
<b class="fc">&nbsp;    this.indent = builder.indent;</b>
&nbsp;
<b class="fc">&nbsp;    Set&lt;String&gt; alwaysQualifiedNames = new LinkedHashSet&lt;&gt;();</b>
<b class="fc">&nbsp;    fillAlwaysQualifiedNames(builder.typeSpec, alwaysQualifiedNames);</b>
<b class="fc">&nbsp;    this.alwaysQualify = Util.immutableSet(alwaysQualifiedNames);</b>
&nbsp;  }
&nbsp;
&nbsp;  private void fillAlwaysQualifiedNames(TypeSpec spec, Set&lt;String&gt; alwaysQualifiedNames) {
<b class="fc">&nbsp;    alwaysQualifiedNames.addAll(spec.alwaysQualifiedNames);</b>
<b class="fc">&nbsp;    for (TypeSpec nested : spec.typeSpecs) {</b>
<b class="fc">&nbsp;      fillAlwaysQualifiedNames(nested, alwaysQualifiedNames);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  public void writeTo(Appendable out) throws IOException {
&nbsp;    // First pass: emit the entire class, just to collect the types we&#39;ll need to import.
<b class="fc">&nbsp;    CodeWriter importsCollector = new CodeWriter(</b>
&nbsp;        NULL_APPENDABLE,
&nbsp;        indent,
&nbsp;        staticImports,
&nbsp;        alwaysQualify
&nbsp;    );
<b class="fc">&nbsp;    emit(importsCollector);</b>
<b class="fc">&nbsp;    Map&lt;String, ClassName&gt; suggestedImports = importsCollector.suggestedImports();</b>
&nbsp;
&nbsp;    // Second pass: write the code, taking advantage of the imports.
<b class="fc">&nbsp;    CodeWriter codeWriter</b>
&nbsp;        = new CodeWriter(out, indent, suggestedImports, staticImports, alwaysQualify);
<b class="fc">&nbsp;    emit(codeWriter);</b>
&nbsp;  }
&nbsp;
&nbsp;  /** Writes this to {@code directory} as UTF-8 using the standard directory structure. */
&nbsp;  public void writeTo(Path directory) throws IOException {
<b class="fc">&nbsp;    writeToPath(directory);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Writes this to {@code directory} with the provided {@code charset} using the standard directory
&nbsp;   * structure.
&nbsp;   */
&nbsp;  public void writeTo(Path directory, Charset charset) throws IOException {
<b class="fc">&nbsp;    writeToPath(directory, charset);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Writes this to {@code directory} as UTF-8 using the standard directory structure.
&nbsp;   * Returns the {@link Path} instance to which source is actually written.
&nbsp;   */
&nbsp;  public Path writeToPath(Path directory) throws IOException {
<b class="fc">&nbsp;    return writeToPath(directory, UTF_8);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Writes this to {@code directory} with the provided {@code charset} using the standard directory
&nbsp;   * structure.
&nbsp;   * Returns the {@link Path} instance to which source is actually written.
&nbsp;   */
&nbsp;  public Path writeToPath(Path directory, Charset charset) throws IOException {
<b class="pc">&nbsp;    checkArgument(Files.notExists(directory) || Files.isDirectory(directory),</b>
&nbsp;        &quot;path %s exists but is not a directory.&quot;, directory);
<b class="fc">&nbsp;    Path outputDirectory = directory;</b>
<b class="fc">&nbsp;    if (!packageName.isEmpty()) {</b>
<b class="fc">&nbsp;      for (String packageComponent : packageName.split(&quot;\\.&quot;)) {</b>
<b class="fc">&nbsp;        outputDirectory = outputDirectory.resolve(packageComponent);</b>
&nbsp;      }
<b class="fc">&nbsp;      Files.createDirectories(outputDirectory);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    Path outputPath = outputDirectory.resolve(typeSpec.name + &quot;.java&quot;);</b>
<b class="fc">&nbsp;    try (Writer writer = new OutputStreamWriter(Files.newOutputStream(outputPath), charset)) {</b>
<b class="fc">&nbsp;      writeTo(writer);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    return outputPath;</b>
&nbsp;  }
&nbsp;
&nbsp;  /** Writes this to {@code directory} as UTF-8 using the standard directory structure. */
&nbsp;  public void writeTo(File directory) throws IOException {
<b class="fc">&nbsp;    writeTo(directory.toPath());</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Writes this to {@code directory} as UTF-8 using the standard directory structure.
&nbsp;   * Returns the {@link File} instance to which source is actually written.
&nbsp;   */
&nbsp;  public File writeToFile(File directory) throws IOException {
<b class="fc">&nbsp;    final Path outputPath = writeToPath(directory.toPath());</b>
<b class="fc">&nbsp;    return outputPath.toFile();</b>
&nbsp;  }
&nbsp;
&nbsp;  /** Writes this to {@code filer}. */
&nbsp;  public void writeTo(Filer filer) throws IOException {
<b class="fc">&nbsp;    String fileName = packageName.isEmpty()</b>
<b class="fc">&nbsp;        ? typeSpec.name</b>
<b class="fc">&nbsp;        : packageName + &quot;.&quot; + typeSpec.name;</b>
<b class="fc">&nbsp;    List&lt;Element&gt; originatingElements = typeSpec.originatingElements;</b>
<b class="fc">&nbsp;    JavaFileObject filerSourceFile = filer.createSourceFile(fileName,</b>
<b class="fc">&nbsp;        originatingElements.toArray(new Element[originatingElements.size()]));</b>
<b class="pc">&nbsp;    try (Writer writer = filerSourceFile.openWriter()) {</b>
<b class="fc">&nbsp;      writeTo(writer);</b>
<b class="pc">&nbsp;    } catch (Exception e) {</b>
&nbsp;      try {
<b class="nc">&nbsp;        filerSourceFile.delete();</b>
<b class="nc">&nbsp;      } catch (Exception ignored) {</b>
<b class="nc">&nbsp;      }</b>
<b class="nc">&nbsp;      throw e;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  private void emit(CodeWriter codeWriter) throws IOException {
<b class="fc">&nbsp;    codeWriter.pushPackage(packageName);</b>
&nbsp;
<b class="fc">&nbsp;    if (!fileComment.isEmpty()) {</b>
<b class="fc">&nbsp;      codeWriter.emitComment(fileComment);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    if (!packageName.isEmpty()) {</b>
<b class="fc">&nbsp;      codeWriter.emit(&quot;package $L;\n&quot;, packageName);</b>
<b class="fc">&nbsp;      codeWriter.emit(&quot;\n&quot;);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    if (!staticImports.isEmpty()) {</b>
<b class="fc">&nbsp;      for (String signature : staticImports) {</b>
<b class="fc">&nbsp;        codeWriter.emit(&quot;import static $L;\n&quot;, signature);</b>
<b class="fc">&nbsp;      }</b>
<b class="fc">&nbsp;      codeWriter.emit(&quot;\n&quot;);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    int importedTypesCount = 0;</b>
<b class="fc">&nbsp;    for (ClassName className : new TreeSet&lt;&gt;(codeWriter.importedTypes().values())) {</b>
&nbsp;      // TODO what about nested types like java.util.Map.Entry?
<b class="fc">&nbsp;      if (skipJavaLangImports</b>
<b class="fc">&nbsp;          &amp;&amp; className.packageName().equals(&quot;java.lang&quot;)</b>
<b class="pc">&nbsp;          &amp;&amp; !alwaysQualify.contains(className.simpleName)) {</b>
<b class="fc">&nbsp;        continue;</b>
&nbsp;      }
<b class="fc">&nbsp;      codeWriter.emit(&quot;import $L;\n&quot;, className.withoutAnnotations());</b>
<b class="fc">&nbsp;      importedTypesCount++;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    if (importedTypesCount &gt; 0) {</b>
<b class="fc">&nbsp;      codeWriter.emit(&quot;\n&quot;);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    typeSpec.emit(codeWriter, null, Collections.emptySet());</b>
&nbsp;
<b class="fc">&nbsp;    codeWriter.popPackage();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override public boolean equals(Object o) {
<b class="pc">&nbsp;    if (this == o) return true;</b>
<b class="pc">&nbsp;    if (o == null) return false;</b>
<b class="pc">&nbsp;    if (getClass() != o.getClass()) return false;</b>
<b class="fc">&nbsp;    return toString().equals(o.toString());</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override public int hashCode() {
<b class="nc">&nbsp;    return toString().hashCode();</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override public String toString() {
&nbsp;    try {
<b class="fc">&nbsp;      StringBuilder result = new StringBuilder();</b>
<b class="fc">&nbsp;      writeTo(result);</b>
<b class="fc">&nbsp;      return result.toString();</b>
<b class="nc">&nbsp;    } catch (IOException e) {</b>
<b class="nc">&nbsp;      throw new AssertionError();</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  public JavaFileObject toJavaFileObject() {
<b class="fc">&nbsp;    URI uri = URI.create((packageName.isEmpty()</b>
<b class="fc">&nbsp;        ? typeSpec.name</b>
<b class="fc">&nbsp;        : packageName.replace(&#39;.&#39;, &#39;/&#39;) + &#39;/&#39; + typeSpec.name)</b>
&nbsp;        + Kind.SOURCE.extension);
<b class="fc">&nbsp;    return new SimpleJavaFileObject(uri, Kind.SOURCE) {</b>
<b class="fc">&nbsp;      private final long lastModified = System.currentTimeMillis();</b>
&nbsp;      @Override public String getCharContent(boolean ignoreEncodingErrors) {
<b class="fc">&nbsp;        return JavaFile.this.toString();</b>
&nbsp;      }
&nbsp;      @Override public InputStream openInputStream() throws IOException {
<b class="fc">&nbsp;        return new ByteArrayInputStream(getCharContent(true).getBytes(UTF_8));</b>
&nbsp;      }
&nbsp;      @Override public long getLastModified() {
<b class="nc">&nbsp;        return lastModified;</b>
&nbsp;      }
&nbsp;    };
&nbsp;  }
&nbsp;
&nbsp;  public static Builder builder(String packageName, TypeSpec typeSpec) {
<b class="fc">&nbsp;    checkNotNull(packageName, &quot;packageName == null&quot;);</b>
<b class="fc">&nbsp;    checkNotNull(typeSpec, &quot;typeSpec == null&quot;);</b>
<b class="fc">&nbsp;    return new Builder(packageName, typeSpec);</b>
&nbsp;  }
&nbsp;
&nbsp;  public Builder toBuilder() {
<b class="nc">&nbsp;    Builder builder = new Builder(packageName, typeSpec);</b>
<b class="nc">&nbsp;    builder.fileComment.add(fileComment);</b>
<b class="nc">&nbsp;    builder.skipJavaLangImports = skipJavaLangImports;</b>
<b class="nc">&nbsp;    builder.indent = indent;</b>
<b class="nc">&nbsp;    return builder;</b>
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  public static final class Builder {</b>
&nbsp;    private final String packageName;
&nbsp;    private final TypeSpec typeSpec;
<b class="fc">&nbsp;    private final CodeBlock.Builder fileComment = CodeBlock.builder();</b>
&nbsp;    private boolean skipJavaLangImports;
<b class="fc">&nbsp;    private String indent = &quot;  &quot;;</b>
&nbsp;
<b class="fc">&nbsp;    public final Set&lt;String&gt; staticImports = new TreeSet&lt;&gt;();</b>
&nbsp;
<b class="fc">&nbsp;    private Builder(String packageName, TypeSpec typeSpec) {</b>
<b class="fc">&nbsp;      this.packageName = packageName;</b>
<b class="fc">&nbsp;      this.typeSpec = typeSpec;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Builder addFileComment(String format, Object... args) {
<b class="fc">&nbsp;      this.fileComment.add(format, args);</b>
<b class="fc">&nbsp;      return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Builder addStaticImport(Enum&lt;?&gt; constant) {
<b class="fc">&nbsp;      return addStaticImport(ClassName.get(constant.getDeclaringClass()), constant.name());</b>
&nbsp;    }
&nbsp;
&nbsp;    public Builder addStaticImport(Class&lt;?&gt; clazz, String... names) {
<b class="fc">&nbsp;      return addStaticImport(ClassName.get(clazz), names);</b>
&nbsp;    }
&nbsp;
&nbsp;    public Builder addStaticImport(ClassName className, String... names) {
<b class="pc">&nbsp;      checkArgument(className != null, &quot;className == null&quot;);</b>
<b class="pc">&nbsp;      checkArgument(names != null, &quot;names == null&quot;);</b>
<b class="pc">&nbsp;      checkArgument(names.length &gt; 0, &quot;names array is empty&quot;);</b>
<b class="fc">&nbsp;      for (String name : names) {</b>
<b class="pc">&nbsp;        checkArgument(name != null, &quot;null entry in names array: %s&quot;, Arrays.toString(names));</b>
<b class="fc">&nbsp;        staticImports.add(className.canonicalName + &quot;.&quot; + name);</b>
&nbsp;      }
<b class="fc">&nbsp;      return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Call this to omit imports for classes in {@code java.lang}, such as {@code java.lang.String}.
&nbsp;     *
&nbsp;     * &lt;p&gt;By default, JavaPoet explicitly imports types in {@code java.lang} to defend against
&nbsp;     * naming conflicts. Suppose an (ill-advised) class is named {@code com.example.String}. When
&nbsp;     * {@code java.lang} imports are skipped, generated code in {@code com.example} that references
&nbsp;     * {@code java.lang.String} will get {@code com.example.String} instead.
&nbsp;     */
&nbsp;    public Builder skipJavaLangImports(boolean skipJavaLangImports) {
<b class="fc">&nbsp;      this.skipJavaLangImports = skipJavaLangImports;</b>
<b class="fc">&nbsp;      return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Builder indent(String indent) {
<b class="fc">&nbsp;      this.indent = indent;</b>
<b class="fc">&nbsp;      return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    public JavaFile build() {
<b class="fc">&nbsp;      return new JavaFile(this);</b>
&nbsp;    }
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-11-04 13:59</div>
</div>
</body>
</html>
